#HW3
import numpy as np

def compute_hamiltonian(x, y, x0, y0, px, py, omega_x, omega_y, delta, delta_12, cx, cy):
    '''
    This function computes Hamiltonian matrix
    x0 (float): initial position in x direction
    y0 (float): initial position in y direction
    px (float): momentum in x direction
    py (float): momentum in y direction
    Vector omega = (omega_x, omega_y) : is a normal vector to the degeneracy line where VD = VA
    delta (float): energy difference between V_D and V_A
    delta_12 (float): determines the displacement of the zero coupling line along the C vector
    Vector C = (CX, CY) : determines a coupling directionand is a normal vector to a zero coupling...
    line where Vc = 0
    Returns:
    H (matrix): Hamiltonian matrix'''
    
    TS = 0.5*(px**2+py**2)
    TS = np.array([[TS, 0],[0, TS]])
    VD = 0.5 * ((omega_x**2)*(x+x0)**2+(omega_y**2)*(y+y0)**2+delta)
    VA = 0.5 * ((omega_x**2)*(x-x0)**2+(omega_y**2)*(y-y0)**2-delta)
    VC = cx*x+cy*y+delta_12
    HS = TS+np.array([[VA,VC],[VC,VD]])


    q = [1,2,3,4,5,6]
    omega = [1,2,3,4,5,6]
    p = [1,2,3,4,5,6]
    N = 6
    valueb = 0
    for j in range(0,N-2):
        valueb = valueb + (p[j]**2+(omega[j]**2)*(q[j]**2))
    valueb = 0.5*valueb
    HB = np.array([[valueb,0],[0,valueb]])


    lmbdax = [1,2,3,4,5,6]
    lmbday = [1,2,3,4,5,6]
    N = 6
    valuesb = 0
    for j in range(0,N-2):
        valuesb = valuesb + (lmbdax[j]*x+lmbday[j]*y)*q[j]
    HSB = np.array([[valuesb,0],[0,valuesb]])
    
    H = HS+HSB+HB
    return H
    
    
    
    

#HW4
import numpy as np

def root_finder(f_name, f_params, left, right, precision):
    '''
    Find the root of the function on the interval (left to right) with the specified precision.
    f_name: The function whose root we are looking for.
    f_params (tuple): A tuple of parameters to pass to the function f_name.
    left (float): The left endpoint of the interval to search for a root.
    right (float): The right endpoint of the interval to search for a root.
    precision (float): The desired precision of the root.
    Returns:
    float: The root of the function f_name on the interval (left to right).'''

    while abs(right - left) > precision:
        midpoint = (left + right) / 2
        if f_name(midpoint, f_params[0], f_params[1], f_params[2]) * f_name(left, f_params[0], f_params[1], f_params[2]) < 0:
            right = midpoint
        else:
            left = midpoint
    return (left + right) / 2

def fermi_energy(levels, N, kT):
    '''
    Find the Fermi energy for a system of energy levels and N electrons.
    levels (list): A list of energy levels.
    N (int): The number of electrons.
    kT (float): The thermal energy.
    Returns:
    float: The Fermi energy of the system.'''
    f_params = (levels, N, kT)
    left = min(levels)
    right = max(levels)
    precision = 1e-6
    def f_name(E, levels, N, kT):
        value = 0
        for level in levels:
            value = value + 1 / (1 + np.exp((E - level) / kT))
            return value - N
    return root_finder(f_name, f_params, left, right, precision)




#HW5
import numpy as np

class Hamiltonian:
    def __init__(self, x0, y0, px, py, omega_x, omega_y, delta, delta_12, cx, cy):
        self.x0 = x0
        self.y0 = y0
        self.px = px
        self.py = py
        self.omega_x = omega_x
        self.omega_y = omega_y
        self.delta = delta
        self.delta_12 = delta_12
        self.cx = cx
        self.cy = cy

    def compute_hamiltonian(self, x, y):
        TS = 0.5 * (self.px**2 + self.py**2)
        TS = np.array([[TS, 0], [0, TS]])
        
        VD = 0.5 * ((self.omega_x**2) * (x + self.x0)**2 + (self.omega_y**2) * (y + self.y0)**2 + self.delta)
        VA = 0.5 * ((self.omega_x**2) * (x - self.x0)**2 + (self.omega_y**2) * (y - self.y0)**2 - self.delta)
        VC = self.cx * x + self.cy * y + self.delta_12
        HS = TS + np.array([[VA, VC], [VC, VD]])

        q = [1, 2, 3, 4, 5, 6]
        omega = [1, 2, 3, 4, 5, 6]
        p = [1, 2, 3, 4, 5, 6]
        N = 6
        valueb = 0
        for j in range(0, N - 2):
            valueb = valueb + (p[j]**2 + (omega[j]**2) * (q[j]**2))
        valueb = 0.5 * valueb
        HB = np.array([[valueb, 0], [0, valueb]])

        lmbdax = [1, 2, 3, 4, 5, 6]
        lmbday = [1, 2, 3, 4, 5, 6]
        N = 6
        valuesb = 0
        for j in range(0, N - 2):
            valuesb = valuesb + (lmbdax[j] * x + lmbday[j] * y) * q[j]
        HSB = np.array([[valuesb, 0], [0, valuesb]])

        H = HS + HSB + HB
        return H

# Example
hamiltonian = Hamiltonian(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
H = hamiltonian.compute_hamiltonian(1, 2)
print(H)



#HW6
import numpy as np

def compute_hamiltonian(x, y, x0, y0, px, py, omega_x, omega_y, delta, delta_12, cx, cy):
    '''
    This function computes Hamiltonian matrix
    x0 (float): initial position in x direction
    y0 (float): initial position in y direction
    px (float): momentum in x direction
    py (float): momentum in y direction
    Vector omega = (omega_x, omega_y) : is a normal vector to the degeneracy line where VD = VA
    delta (float): energy difference between V_D and V_A
    delta_12 (float): determines the displacement of the zero coupling line along the C vector
    Vector C = (CX, CY) : determines a coupling directionand is a normal vector to a zero coupling...
    line where Vc = 0
    Returns:
    H (matrix): Hamiltonian matrix'''
    
    TS = 0.5*(px**2+py**2)
    TS = np.array([[TS, 0],[0, TS]])
    VD = 0.5 * ((omega_x**2)*(x+x0)**2+(omega_y**2)*(y+y0)**2+delta)
    VA = 0.5 * ((omega_x**2)*(x-x0)**2+(omega_y**2)*(y-y0)**2-delta)
    VC = cx*x+cy*y+delta_12
    HS = TS+np.array([[VA,VC],[VC,VD]])


    q = [1,2,3,4,5,6]
    omega = [1,2,3,4,5,6]
    p = [1,2,3,4,5,6]
    N = 6
    valueb = 0
    for j in range(0,N-2):
        valueb = valueb + (p[j]**2+(omega[j]**2)*(q[j]**2))
    valueb = 0.5*valueb
    HB = np.array([[valueb,0],[0,valueb]])


    lmbdax = [1,2,3,4,5,6]
    lmbday = [1,2,3,4,5,6]
    N = 6
    valuesb = 0
    for j in range(0,N-2):
        valuesb = valuesb + (lmbdax[j]*x+lmbday[j]*y)*q[j]
    HSB = np.array([[valuesb,0],[0,valuesb]])
    
    H = HS+HSB+HB
    return H

f = open('myfile.txt','a')
for x in range(-10,10):
    fx = compute_hamiltonian(x, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0 , 10.0)
    f.write(f'{x} {fx[0,0]} {fx[1,0]} {fx[0,1]} {fx[1,1]}\n')
f.close()



#HW7
import numpy as np
import matplotlib.pyplot as plt

def compute_hamiltonian(x, y, x0, y0, px, py, omega_x, omega_y, delta, delta_12, cx, cy):
    '''
    This function computes Hamiltonian matrix
    x0 (float): initial position in x direction
    y0 (float): initial position in y direction
    px (float): momentum in x direction
    py (float): momentum in y direction
    Vector omega = (omega_x, omega_y) : is a normal vector to the degeneracy line where VD = VA
    delta (float): energy difference between V_D and V_A
    delta_12 (float): determines the displacement of the zero coupling line along the C vector
    Vector C = (CX, CY) : determines a coupling directionand is a normal vector to a zero coupling...
    line where Vc = 0
    Returns:
    H (matrix): Hamiltonian matrix'''
    
    TS = 0.5*(px**2+py**2)
    TS = np.array([[TS, 0],[0, TS]])
    VD = 0.5 * ((omega_x**2)*(x+x0)**2+(omega_y**2)*(y+y0)**2+delta)
    VA = 0.5 * ((omega_x**2)*(x-x0)**2+(omega_y**2)*(y-y0)**2-delta)
    VC = cx*x+cy*y+delta_12
    HS = TS+np.array([[VA,VC],[VC,VD]])


    q = [1,2,3,4,5,6]
    omega = [1,2,3,4,5,6]
    p = [1,2,3,4,5,6]
    N = 6
    valueb = 0
    for j in range(0,N-2):
        valueb = valueb + (p[j]**2+(omega[j]**2)*(q[j]**2))
    valueb = 0.5*valueb
    HB = np.array([[valueb,0],[0,valueb]])


    lmbdax = [1,2,3,4,5,6]
    lmbday = [1,2,3,4,5,6]
    N = 6
    valuesb = 0
    for j in range(0,N-2):
        valuesb = valuesb + (lmbdax[j]*x+lmbday[j]*y)*q[j]
    HSB = np.array([[valuesb,0],[0,valuesb]])
    
    H = HS+HSB+HB
    return H

first_dignl_elem = []
sec_dignl_elem = []
for x in range(-10,10):
    fx = compute_hamiltonian(x, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0 , 10.0)
    first_dignl_elem.append(fx[0,0])
    sec_dignl_elem.append(fx[1,1])
plt.plot(range(-10,10), first_dignl_elem, label='H[0, 0]')
plt.plot(range(-10,10), sec_dignl_elem, label='H[1, 1]')
plt.xlabel('x')
plt.ylabel('Hamiltonian Value')
plt.legend()
plt.title('Hamiltonian values vs. x-axis')
plt.show()


